
        CONSTANT IO_Port,  00
        CONSTANT LED0,     01
        CONSTANT LED1,     02
        CONSTANT BNT0,     04
        
        CONSTANT COM_Port, 01
        CONSTANT TXD,      01
        CONSTANT RXD,      01

; Register Mapping
; alle acht Register s0 bis s7 stehen der ISR zur Verfuegung
        NAMEREG s0, IOR
        NAMEREG s1, TMP
        NAMEREG s2, CNTH
        NAMEREG s3, CNTL
		
		NAMEREG s4, COUNTER
		NAMEREG s5, IDLE_STATE
		NAMEREG s6, READ_MODE
		NAMEREG s7, SAVED_BITS
		NAMEREG s8, DATA

; alle acht Register s8 bis sF stehen der Main-Funktion zur Verfuegung

; --------------------------------------------------------------------------------------------

        ADDRESS 000
; Hauptfunktion
start:  AND    CNTH, 00   ; Initialisierung der Zaehlers ...
        AND    CNTL, 00   ; in der ISR
		OR     IDLE_STATE, 01 ; Programm ist zunächst immer idle
		AND	   READ_MODE, 00 ; initial Modus zur Startbiterkennung
		AND    SAVED_BITS, 00 ; initial keine Bits eingelesen
		AND    DATA, 00
        ENABLE INTERRUPT
loop:   ; do nothing
        JUMP loop

; --------------------------------------------------------------------------------------------
 
; Subroutine, die den Zustand des Buttons BTN0 auf die Leuchtdiode LED0 durchschaltet
BNT0LED0:
        INPUT  IOR,  IO_Port ; IO-Port einlesen
        INPUT  TMP,  IO_Port ; IO-Port einlesen
        AND    TMP,  BNT0    ; Zustand von BNT0 ermitteln
        SR0    TMP           ; auf die Position ...
        SR0    TMP           ; ... von LED0 verschieben
        AND    IOR,  LED1    ; Zustand von LED1 ermitteln
        OR     IOR,  TMP     ; LED1 mit BNT0 konkatinieren
        OUTPUT IOR,  IO_Port ; den neuen Wert ueber IO-Port ausgeben 
        RETURN

; --------------------------------------------------------------------------------------------

; Subroutine, die die Leuchtdione LED1 mit ca. 1 Hz blinken laesst
BLINK:  ADD    CNTL, 01      ; den 16-Bit-Zaehler ... 
        ADDCY  CNTH, 00      ; .. inkrementieren
        JUMP   NC,   BLINK0  ; kein Ueberlauf -> exit, sonst
        INPUT  IOR,  IO_Port ; IO-Port einlesen
        XOR    IOR,  LED1    ; LED1 toggeln
        OUTPUT IOR,  IO_Port ; den neuen Wert ueber IO-Port ausgeben 
BLINK0: RETURN

; --------------------------------------------------------------------------------------------

; Subroutine, die Daten ueber das serielle Eingangssignal RXD abtastet,
; zu einem Byte zusammensetzt, entschidet, ob das empfangene Byte
; ein Buchstabe oder eine Ziffer ist, und ggf. das Byte seriell
; ueber das serielle Ausgangssignal TXD ausgibt
;
; in dieser Version ist eine einfache Echo-Funktion implementiert
	CONSTANT BEGINZAHL,		30
	CONSTANT ENDZAHL,		39
	CONSTANT BEGINGROSS,	41
	CONSTANT ENDGROSS,		5A
	CONSTANT BEGINKLEIN,	61
	CONSTANT ENDKLEINKLEIN,	7A

COMM:   
        INPUT  IOR,  COM_Port ; COM-Port einlesen
		COMPARE IOR, 01		  ; Prüfen ob COM_Port == 1
		JUMP Z, CHECK_IDLE_STATE ; Prüfe ob Programm idle ist -> idle bleiben
		JUMP NZ, PROCESS_BIT  ; Eingehendes Bit verarbeiten
		RETURN

; --------------------------------------------------------------------------------------------

CHECK_IDLE_STATE:

		COMPARE IDLE_STATE, 01
		JUMP NZ, PROCESS_BIT
		AND COUNTER, 00 ; Falls wir im idle state sind muss der Counter immer auf 0 sein bzw. zurückgesetzt werden
		RETURNI ENABLE 	; ISR beenden falls Zustand idle ist

; --------------------------------------------------------------------------------------------

PROCESS_BIT:
		COMPARE READ_MODE, 01 ; Prüfe ob Startbiterkennung (0) oder Datenübernahme (1)
		JUMP Z, DATENÜBERNAHME
		JUMP NZ, STARTBITERKENNUNG

; --------------------------------------------------------------------------------------------

STARTBITERKENNUNG:
		ADD COUNTER, 01 ; Counter inkrementieren
		COMPARE COUNTER, 08 ; Überprüfe ob 8 Takte vergangen sind
		JUMP Z, ENTER_DATATRANSFER
		RETURNI ENABLE ; ISR beenden falls Counter noch nicht 8 erreicht hat

; --------------------------------------------------------------------------------------------

ENTER_DATATRANSFER:
		AND IDLE_STATE, 00 ; Programm wird nicht mehr als idle betrachtet
		OR READ_MODE, 01 ; Nun können wir anfangen Bits zu lesen
		AND COUNTER, 00 ; Setze Counter zurück, sodass wir diesen später auf 16 zählen können
		RETURNI ENABLE ; Startbit muss nicht in Datenregister zurückgeschrieben werden, da es sowieso eine 0 ist
		
; --------------------------------------------------------------------------------------------

DATENÜBERNAHME:
		ADD COUNTER, 01 ; Counter inkrementieren
		COMPARE COUNTER, 16 ; Prüfe ob 16 Takte vergangen sind
		JUMP Z, SAVE_DATA_BIT
		RETURNI ENABLE ; ISR beenden falls Counter noch nicht 16 erreicht hat
		
; --------------------------------------------------------------------------------------------

SAVE_DATA_BIT:
		COMPARE SAVED_BITS, 08 ; Schauen ob alle Datenbits schon da sind
		JUMP Z, CHECK_STOP_BIT ; TODO
		; TODO 
		TODO
		
		
; --------------------------------------------------------------------------------------------

WRITE_BACK:
		OUTPUT IOR,  COM_Port ; TXD ausgeben
		RETURN
		
; --------------------------------------------------------------------------------------------
        
        ADDRESS 300
; Interrupt-Service-Routine
ISR:    CALL    BNT0LED0
        CALL    BLINK
        CALL    COMM
        RETURNI ENABLE

; --------------------------------------------------------------------------------------------

; Interrupt-Vektor
        ADDRESS 3FF
        JUMP ISR

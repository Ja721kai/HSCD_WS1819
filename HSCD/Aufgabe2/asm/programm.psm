
		CONSTANT IO_Port,  00
        CONSTANT LED0,     01
        CONSTANT LED1,     02
        CONSTANT BNT0,     04
        
        CONSTANT COM_Port, 01
        CONSTANT TXD,      01
        CONSTANT RXD,      01
		
		CONSTANT RAM_ADR   02
		CONSTANT RAM_DATA  04
		
		CONSTANT BEGINZAHL,		30 ; ASCII Zeichen 0
		CONSTANT ENDZAHL,		3A ; ASCII Zeichen 9 + 1
		CONSTANT BEGINGROSS,	41 ; ASCII Zeichen A
		CONSTANT ENDGROSS,		5B ; ASCII Zeichen Z + 1
		CONSTANT BEGINKLEIN,	61 ; ASCII Zeichen a
		CONSTANT ENDKLEIN,  	7B ; ASCII Zeichen z + 1
		
		CONSTANT ZERO,	   00
		CONSTANT ONE,	   01
		CONSTANT SEVEN,    07
		CONSTANT EIGHT,    08
		CONSTANT SIXTEEN,  10

; Register Mapping
; alle acht Register s0 bis s7 stehen der ISR zur Verfuegung
        NAMEREG s0, IOR
        NAMEREG s1, TMP
        NAMEREG s2, CNTH
        NAMEREG s3, CNTL
		
		NAMEREG s4, COUNTER		; Counter für Comm_in und Comm_out
		NAMEREG s5, DATA		; Datenregister für Comm_in und Comm_out
		NAMEREG s6, WRITE		; Semaphor für Read/Write aus RAM
		NAMEREG s7, DATA_COUNT  ; Zählt wv Bits eingelesen wurden in Datenregister
		NAMEREG s8, STATE       ; Zustandsmaschine
		
		NAMEREG s9, DATABLOCK_COUNTER  ; Größe des Datenblocks
		NAMEREG sA, ADR_W			; Adresspointer zum Schreiben auf RAM-Block
		NAMEREG sB, ADR_R           ; Adresspointer zum Lesen von RAM-Block

; alle acht Register s8 bis sF stehen der Main-Funktion zur Verfuegung

; --------------------------------------------------------------------------------------------

        ADDRESS 000
; Hauptfunktion
start:  AND    CNTH, 00   ; Initialisierung der Zaehlers ...
        AND    CNTL, 00   ; in der ISR
			
		LOAD   STATE, 11
		LOAD   WRITE, 00  ; Schreiberlaubnis
		LOAD   ADR_W, 00  ; Zeiger auf RAM-Block Adresse 00
		
		LOAD   DATABLOCK_COUNTER, SIXTEEN
		
        ENABLE INTERRUPT
loop:   ; do nothing
        JUMP loop

; --------------------------------------------------------------------------------------------
 
; Subroutine, die den Zustand des Buttons BTN0 auf die Leuchtdiode LED0 durchschaltet
BNT0LED0:
        INPUT  IOR,  IO_Port ; IO-Port einlesen
        INPUT  TMP,  IO_Port ; IO-Port einlesen
        AND    TMP,  BNT0    ; Zustand von BNT0 ermitteln
        SR0    TMP           ; auf die Position ...
        SR0    TMP           ; ... von LED0 verschieben
        AND    IOR,  LED1    ; Zustand von LED1 ermitteln
        OR     IOR,  TMP     ; LED1 mit BNT0 konkatinieren
        OUTPUT IOR,  IO_Port ; den neuen Wert ueber IO-Port ausgeben 
        RETURN

; --------------------------------------------------------------------------------------------

; Subroutine, die die Leuchtdione LED1 mit ca. 1 Hz blinken laesst
BLINK:  ADD    CNTL, 01      ; den 16-Bit-Zaehler ... 
        ADDCY  CNTH, 00      ; .. inkrementieren
        JUMP   NC,   BLINK0  ; kein Ueberlauf -> exit, sonst
        INPUT  IOR,  IO_Port ; IO-Port einlesen
        XOR    IOR,  LED1    ; LED1 toggeln
        OUTPUT IOR,  IO_Port ; den neuen Wert ueber IO-Port ausgeben 
BLINK0: RETURN

; --------------------------------------------------------------------------------------------

; Subroutine, die Daten ueber das serielle Eingangssignal RXD abtastet,
; zu einem Byte zusammensetzt, entschidet, ob das empfangene Byte
; ein Buchstabe oder eine Ziffer ist, und ggf. das Byte seriell
; ueber das serielle Ausgangssignal TXD ausgibt

; ------------------- Zustandsautomat zum Festlegen des Lesezustandes ------------------------

COMM_IN:
		; Die Zustände sind zirkulär angeordnet und im Regelfall über eine 1-Bit Rotation erreichbar
		COMPARE WRITE, 00				
		RETURN NZ						; Schreiben nicht erlaubt wenn WRITE 1 ist
		COMPARE STATE, 44
		JUMP Z, DATENUEBERNAHME			; Abspeichern der Datenbits und Übergang auf 88
		COMPARE STATE, 88
		JUMP Z, CHECK_STOP_BIT			; Erkennen des Stopbits und Übergang auf 11
		COMPARE STATE, 22
		JUMP Z, STARTBITVALIDIERUNG		; Wenn das Startbit 8 Takte vorliegt geht man in Zustand 44 über
		COMPARE STATE, 11
		JUMP Z, FLANK_DETECTION			; Liegt eine Abwärtsflanke vor, so geht man in Zustand 22 über
		

; ----------------------- Zustand 11 : Flankenerkennung -----------------------------

; Sobald im Zustand 11 eine Abwärtsflanke erkannt wird liegt das Startbit vor
FLANK_DETECTION:
		INPUT IOR, COM_Port ; COM_Port einlesen
		COMPARE IOR, 01     ; Falls IOR 1 ist, also kein Startbit
		RETURN Z            ; Beende Einlesen
		; Ansonsten muss IOR bereits 0 sein -> nur noch 7 Takte abzählen
		LOAD COUNTER, SEVEN
		LOAD STATE, 22          ; Rotiere nach links von 11 nach 22
		RETURN

; --------------------- Zustand 22 : Startbitvalidierung ----------------------------
		
; Hier werden nach Erkennung des Starbits 7 Takte abgezählt (insgesamt 8 mit Erkennung)
STARTBITVALIDIERUNG:
		SUB COUNTER, 01 	; Dekrementieren von sieben bis null
		RETURN NZ       	; Beenden sobald keine 8 Takte erreicht wurden
		INPUT IOR, COM_Port ; Nun muss Bit eingelesen und nochmals auf 0 geprüft werden (Rauschprävention)
		COMPARE IOR, 01     ; IOR darf hier nicht 1 sein, sonst liegt ein Fehler vor -> Reset
		JUMP NZ, ENTER_DATATRANSFER
		
; Falls ein Rauschen vorliegt auf Zustand 11 zurückgesetzt werden:
		LOAD STATE, 11         ; Von 22 auf 11 zurück
		RETURN

ENTER_DATATRANSFER:
		LOAD DATA, 00
		LOAD COUNTER, SIXTEEN ; Setze Counter zurück, sodass wir diesen später auf 16 zählen können
		LOAD DATA_COUNT, EIGHT ; Counter um 8 Bits zu zählen bis Zeichen vollständig eingelesen ist
		LOAD STATE, 44	  ; Zustandsübergang von 22 auf 44
		RETURN ; Startbit muss nicht in Datenregister zurückgeschrieben werden, da es sowieso eine 0 ist
		
; --------------------- Zustand 44 : Datenbits einlesen -----------------------------
		
; Nach Ablauf von 16 Takten Bit einlesen und abspeichern
DATENUEBERNAHME:
		SUB COUNTER, 01 	; Dekrementieren von sechzehn bis null
		RETURN NZ
		INPUT IOR, COM_Port ; Zunächst muss das Bit eingelesen werden
		
		OR DATA, IOR 		; Bit eintragen in Datenspeicher
		RR DATA				; Platz schaffen für nächstes Bit
		LOAD COUNTER, SIXTEEN ; Counter wieder zurücksetzen für nächstes Bit
		
		; Wenn 8 Bits erreicht wurden, Übergang nach Zustand 88
		SUB DATA_COUNT, 01  ; Dekrementieren von acht bis null
		RETURN NZ
		
; enter stopbit detection
		LOAD STATE, 88      ; Zustandsübergang von 44 auf 88
		RETURN
		
; --------------------- Zustand 88 : Stopbit erkennen -----------------------------

CHECK_STOP_BIT:
		SUB COUNTER, 01 	; Counter wieder 16 Takte runterzählen
		RETURN NZ
		INPUT IOR, COM_Port ; Bit einlesen
		COMPARE IOR, 01		; Schauen ob Stopbit vorliegt
		JUMP Z, CHECK_DATA  ; Stopbit liegt vor, Überprüfung des ASCII Zeichens
		
		; Sonst müssen alle Daten verworfen und wieder in den Startzustand übergegangen werden
		LOAD STATE, 11	; Übergang von 88 auf 11
		RETURN

; Geprüft wird - wenn möglich - immer nach dem größeren Zahlenintervall um Takte zu optimieren
CHECK_DATA:
		COMPARE DATA, ENDKLEIN         ; Schauen ob wir größer als z sind
		JUMP NC, READ_RESET
		COMPARE DATA, BEGINZAHL		   ; Schauen ob wir kleiner als 0 sind
		JUMP C, READ_RESET
		COMPARE DATA, BEGINKLEIN       ; Schauen ob Kleinbuchstabe vorliegt
		JUMP NC, WRITE_TO_RAM
		COMPARE DATA, ENDGROSS         ; Schauen ob zwischen Z und a
		JUMP NC, READ_RESET
		COMPARE DATA, BEGINGROSS       ; Schauen ob Großbuchstabe vorliegt
		JUMP NC, WRITE_TO_RAM
		COMPARE DATA, ENDZAHL          ; Schauen ob Zahl oder Sonderzeichen
		JUMP C, WRITE_TO_RAM           ; Zahl liegt vor
		JUMP READ_RESET				   ; Sonderzeichen zwischen 9 und A liegt vor

; Zeichen ist valide, kann also auf RAM geschrieben werden
WRITE_TO_RAM:
		OUTPUT ADR, RAM_ADR
		ADD ADR, ONE
		OUTPUT DATA, RAM_DATA ; Schreibe Zeichen in Datenregister an Adresse von ADR
		JUMP READ_RESET

; Zeichen ist komplett eingelesen, Zustände zurücksetzen
READ_RESET:
		LOAD STATE, 11
		SUB DATABLOCK_COUNTER, 01 ; Anzahl der noch zu lesenden ASCII-Zeichen reduzieren
		RETURN NZ
		LOAD ADR_R, ZERO ; Pointer zum Auslesen aus RAM auf 0 setzen
		LOAD WRITE, ONE
		RETURN

; ------------------- Zustandsautomat zum Festlegen des Lesezustandes ------------------------

COMM_OUT:
		COMPARE WRITE, 01
		RETURN NZ						; Schreiben nicht erlaubt wenn WRITE 0 ist
		COMPARE STATE, 22
		JUMP Z, WRITE_DATABIT			; Schreiben des Datenbits
		COMPARE STATE, 44
		JUMP Z, WRITE_STOPBIT			; Stopbit schreiben und Schreibprozess beenden
		COMPARE STATE, 11
		JUMP Z, WRITE_STARTBIT			; Startbit schreiben

; --------------------------- Zustand 11 : Startbit schreiben --------------------------------
WRITE_STARTBIT:
		AND IOR, 00
		OUTPUT IOR, COM_Port
		LOAD COUNTER, SIXTEEN
		LOAD DATA_COUNTER, EIGHT
		; ---- Byte aus RAM Lesen ----------
		OUTPUT ADR_R, RAM_ADR
		ADD ADR_R, 01
		INPUT DATA, RAM_DATA
		; ----------------------------------
		LOAD STATE, 22
		RETURN

; --------------------------- Zustand 22 : Datenbit schreiben ---------------------------------
        
WRITE_DATABIT:
		SUB COUNTER, 01			; Dekrementieren von sechzehn auf null
		RETURN NZ
		LOAD COUNTER, SIXTEEN   ; Wieder auf sechzehn setzen
		
		OUTPUT DATA, COM_Port   ; LSB auf COM_Port schreiben
		SR0 DATA				; LSB flushen
		SUB DATA_COUNT, 01		; Falls DATA_COUNT 0 ist wurden 8 bits geschrieben
		RETURN NZ
		; Ansonsten muss als nächstes Stopbit gesetzt werden
		LOAD STATE, 44		    ; Übergang von 22 auf 44
		
; --------------------------- Zustand 44 : Stopbit schreiben --------------------------------

WRITE_STOPBIT:
		SUB COUNTER, 01
		RETURN NZ
		
		LOAD IOR, 01
		OUTPUT IOR, COM_Port	; Stopbit schreiben

; Semaphor wieder auf 0, falls Datenblock aus RAM gelesen wurde
		COMPARE ADR_W, ADR_R
		RETURN NZ
		LOAD WRITE, ZERO
		LOAD ADR_W, ZERO
		LOAD DATABLOCK_COUNTER, SIXTEEN
		RETURN

; --------------------------------------------------------------------------------------------
		
        ADDRESS 300
; Interrupt-Service-Routine
ISR:    CALL    BNT0LED0
        CALL    BLINK
        CALL    COMM_IN
		CALL 	COMM_OUT
        RETURNI ENABLE

; --------------------------------------------------------------------------------------------

; Interrupt-Vektor
        ADDRESS 3FF
        JUMP ISR
